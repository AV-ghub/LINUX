> Эви Немет, Iр Снайер, 'ент ХеАн, Бен Уэйли, Дэн Маки
> Unix и Linu: руоводство системного адинистратра
> 5-е издание

## КОМПОНЕНТЫ ПРОЦЕССА
**Процесс** состоит из аресного пространства и набора структур дан ных внутри ядра.  
В структурах данных ядра хран ится всевозможная и нформация о кажом процессе.  
**Поток** - это контекст выполнения процесса. Кажый процесс имеет как минимум оди н поток, но некоторые процессы могут иметь несколько потоков. Кажый поток,
действуя в адресном пространстве внешнего процесса, и меет свой собственный стек и регистры центраьного процессора  
### Идентификатор процесса PID
Ядро назначает каждому процессу уникаьный идентификатор. Большинство команд и с истемных вызовов, работающих с процессами, требует указания конкретного иден ­
тификатора, чтобы был ясен контекст операции. Идентификаторы ***PID присваиваются по порядку по мере созания процессов***.   
> В настоящее время система Linux испольует концепцию протранства имен процесса, которая еще больше ограничивает способность процессов видеть
друг дуга и влиять друг на друга. Контейнерные реализации используют эту функцию дя разделения процессов. Оди н из побоч н ых эффектов закл ючается в том, что ***процесс может иметь разные PID в зависимости от пространства имен наблюдателя***.
### Идентификатор родительского процесса PPID
Ни в UNIX, ни в Linux нет систем ного вызов, который б ы инициирова новый процесс дя выполнения конкретной программы. Дя того чтобы породить новый процесс, существующий процесс должен конировать сам себя. Клон может заменить выполняемую программу другой. В операции конирова н ия исходный процесс называют родительским, а его клон - дочерним. Помимо собственного идентификатора, каждый дочерний процесс имеет атрибу PPID ( Prent Process ID), который совпадает с идентификатором породившего его родителького процесса.   
По крайней мере первоначально. Если родительский процесс по какой-то причине завершается раньше потомка, демон init ии sytem (процесс с номером 1 ) подставляет себя на место предка.   
### Идентификатор пользователя UID и текущий идентификатор пользователя EUID
**UID** ( Useг ID) - это идентификатор пользователя , создавшего данн ы й процесс , точнее, копия значения U I D родительского процесса. Менять атрибуты процесса могут
только его созатель (владелец) и суперпользователь.    
**EUID** ( Eﬀective User I D) - это текущи й пользовательский идентификатор процесса, предназначенный дя того, чтобы определить, к каки м ресурсам и файлам у процесса есть право доступа в данный момент. У большинства процессов значения U I D и EU I D одинаковы. Искючение составляют программ ы, у которых установлен бит смены идентификатора пользователя ( ***setuid*** ).  
### Идентификатор группы (GID) и текущий идентификатор группы (EGID)
В значительной степени атрибут G I D процесса является рудиментарным.   
При анализе прав дотупа проверяется текущий идентификатор и дополнительный список групп , но не значение G I D.   
Единственная ситуация, в которой атрибут G I D имеет реал ьное значен ие, - создание процессом новых файлов. В зависимости от установленных прав доступа в данной файловой системе новые файлы могут принимать атрибут G 1 D созающего их процесса.   

## Жизненный цикл ПРОЦЕССА
При загрузке с исте м ы ядро самостоятельно запус кает нескол ько процессов. Наиболее важный из них - демон init или sys te с номером процесса, всегда равным 1 .  
Если родителький процесс завершается раньше срока, то ядро распознает, что вызова wait не поледует, и переназначает все "оиротевшие" процессы демону init (ил и systed). Он берет их под свой контроль, оуществяя дя каждого из н их вызов wаit.   
### Сигналы
Сигнал ы - это запросы н а прерыва н и е , реал изуе м ые н а уровне процессов.  
Когда поступает сигнал , возможен оди н из двух вариантов развития событий. Если процесс назначил сигнау подпрограмму обработки, то после вызова ей предотавляется
информация о контексте, в котором был сгенерирован сигнал. В противном случае ядро выполняет от имени процесса действия, заданные по умолчанию.    
Процедура вызова обработч ика называется переватом сигнала. Когда выполнение обработчи ка завершается , процесс возобновяется с той точки, где был получен сигна.   
### Команда kill: отправка сигналов
Команду **kill** чаще всего используют дя уничтожения процессов. Эта команда может послать процессу любой сигна, но по умолчанию это сигна **TERM**.   
Команду kill могут выполнять как рядовые пол ьзователи (для своих собствен ных процессов) , так и суперпользователь (для любого процесса). Она имеет следующий синтаксис: 
```
kill [ - сигнал ] pid
```  
где сигнал - это номер или символическое имя посылаемого сигнала (см. табл. 4. 1 ) ,   
а pid - идентификационный номер целевого процесса.   
Команда kill без номера сигнала не гарантирует, что процесс будет уничтожен, поскольку сигна TERM можно перехватывать, блокировать и игнорировать.   
Команда
```
$ kill - 9 pid
```  
"гарантированно" уничтожает процесс, так как сигна с номером 9 (KILL) не перехватывается. Используйте команду kill - 9 только в слуае, если " веживый" запро на завершение прграммы не был выполнен. М ы написаи слово " гарантированно" в кавычках, так как иногда прцессы переходт в такое сотояние, в коорм их нельзя завершить даже таким способом (обычно это связно с блокирвкой ввода-вывода, например при отановке жестког диска). Единственный выход в такой ситации - перезгузка.    
Команда **killall** уничтожает процессы , заданные именем. Например, следующая команда уничтожает все процессы веб-сервера Apache.
```
$ sudo killall httd
```   
Команда **pkill** осуществляет поиск процессов, заданных именами (или другим и атрибутами, например E U I D) , и посылает найденным процессам сигнал . Например,
следующая команда посылает сигнал T E RM всем процессам , выполняемым от имени пользователя ben.
```
$ sudo pkill -u Ьn
```   
### Состояния п роцессов и потоков
Процесс может быть приостановлен сигналом STOP и взвращен в активную нагрузку с сигнаом CONT. Сотояние приотновления или выпонения применяется к процессу в целом и наследуется всеми потками процесса.   

## КОМАНДА PS: ТЕКУЩИЙ КОНТРОЛЬ ПРОЦЕССОВ
Процессы-зомби в листинге команды обозначаются как <exiting> или <defunct> .   
Получить список всех процессов, выполняющихся в системах, можно с помощью команды 
```
ps aux
```
Ключ **а** означает, что мы хотим увидеть все процессы, ключ **х** - что мы хотим увидеть даже процессы, отсоединенные от управляющего терминала, а ключ **u** обеспечивает фил ьтрование по имени или идентификатору пользователя, который запустил программу.   

Еще одна полезная аббревиатура, **lax**, предоставляет дополнительную техническую информацию. Кючи а и х описаны выше (отображают все процессы), а кюч 1 означает выбор "динного" формата вывода данных. Команда 
```
ps lax
```   
***выполняется быстрее***, чем команда ps aux, так как не сопоставляет идентификаторы процессов с именами пользователей. Это может оказаться весьма важны м фактором , ***если система уже перегружена*** каким-то процессом.
> В командах с динными списками аргументов вывод командной строки может быть отк ючен. Чтобы отобразить на выходе больше столбцов, добавьте флаг w. Чтобы снять ограничения с ш ирины столбца, добавье флаг w дважды;   
Часто необходимо идентифицировать P I D п роцесса. Вы можете найти PI D, применив команду grep к резульатам работы команды ps:
```
$ ps aux | grep sshd
root 6 8 1 1 О . О О . О 7 8 0 5 6 1 3 4 0 ? S s 1 6 : 0 4 0 : 0 0 / u s r / sb in / s shd
bwh a l e y 1 3 9 6 1 О . О О . О 1 1 0 4 0 8 8 6 8 pt s / 1 S + 2 0 : 3 7 0 : 0 0 grep / u s r / sb in / s shd
```   
Резульаты работы команды ps включают в себя команду grep, так как процесс grep был активен во время выполнения ps.   
Вы можете удалить эту строку из вывода с помощью команды grep -v:
```
$ ps aux | grep -v grep | grep sshd
root 6 8 1 1 О . О О . О 7 8 0 5 6 1 3 4 0 ? S s 1 6 : 0 4 0 : 0 0 / u s r / sb in / s shd
```   
Можно таке определить P I D процесса с помощью команды **pidof**:
```
$ pidof /usr/sbin/sshd
6 8 1 1
```   
Кроме того, можно примен ить утилиту **pgrep**:
```
$ pgrep sshd
6 8 1 1
```   
## ИНТЕРАКТИВНЫЙ МОНИТОРИНГ ПРОЦЕССОВ С ПОМОЩЬЮ КОМАНДЫ ТОР
По умолчанию эта информация обновляется кажые десять секунд. Наиболее активные процессы отображаются первыми. Команда top позволяет также посылать процессам сигнаы и использовать команду **renice**, чтобы пользователь мог наблюдать за тем, как его действия вияют н а общее состоян ие системы.   
> В системе Linux нажмите клавишу 1 (номер один ) , пока команда top предагает перекюч иться межу ядрами.

> Суперпользователь может выполнять команду top ***с параметром -q***, чтобы довести его до максимаьно возможного приоритета. Этот параметр может быть полезен , если вы пытаетесь отследить процесс , который уже привел систему в состояние сбоя.

> Программа **htop**, кросс-платформен ный интерактивный просмотрщик процессов с открытым исходны м кодом, предагающий больше возможностей и имеющий более удобный интерфейс, чем top. 

## КОМАНДЫ NICE И RNICE: ИЗМЕНЕНИЕ ПРИОРИТЕТА ВЫПОЛНЕНИЯ
Диапазон допустимых значений фактора уступчивости зависит от используемой системы. В частности, в системе Linux испол ьзуется диапазон от -20 до + 19.  
Если пользователь не предпринимает специаьных мер, дочерний процесс наследует приоритет своего родительского процесса.    
Влаелец процесса может увеличить фактор уступчивости, но не может уменьшить его.   
Суперпользователь может устанавливать произвольные значения фактора уступчивости.   
Жесткие диски стаи основным узким местом в большинстве операционн ых систем. Фактор уступчивости никак не вияет на подсистемы управения памятью и вводом-выводом , поэтому
даже низкоприоритетный процесс способен монополизировать эти ресурсы или захватить непропорционально большую их часть.   
Фактор уступчивости можно установить при создании процесса с помощью команды **nice**. Команда **renice** позволяет изменять приоритет выполняемого процесса. Первая из этих команд принимает в качестве аргумента строку запуска процесса, а вторая - идентификатор процесса либо имя пользователя.
```
$ nice -n 5 ~/bin/lonqtask // Понижаем приоритет ( увеличиваем фактор уступчивости ) на 5
$ sudo renice -5 8829 // Задаем фактор уступчи вости равным - 5
$ sudo renice 5 -u boqqs // Задаем фактор уступчивости процессов пользователя "boggs" равным 5
```   
> Команда nice определяет только приоритет использован и я центрального процессора. Для управления приоритетами ввода-вывода используется команда **ionice**   
## ФАЙЛОВАЯ СИСТЕМА /proc
> Версии команд ps и top считывают информацию о состоянии процессов из катаога /proc - псевдофайловой системы, в которой ядро помещает большой объем интересной информации о состоянии системы.   

Хранящаяся в этом катаоге и нформация не ограничивается одними л и ш ь процессами - здесь хранится вся информация о состоянии и статистические сведения , генерируемые ядром. Некоторые параметры можно даже изменять, записывая новые значения в сответствующий файл каталога /proc.
Целесообразно просмотреть его, чтобы ознакомитья со веми помещенными в него файлами. Команда **man proc** позволяет ознакомитья с рядом полезных советов и приемов.   
И нформация, относящаяся к конкретн ым процессам, распределена по подкаталогам, названным по идентификаторам процессов. Например, каталог /proc/1 всега содержит и нформацию о демоне init.   

Таблица 4.4. Файлы с информацией о процессах каталога /proc (нумерованные подкаталоги)   

**Файл** **Содержимое**   
**cqroup** Группа управления, которой принадежит процесс   
**Cl** Команда или программа, выполняемая процессом   
**cdline** Полная командная строка процесса (разделенная нулями)   
**cwd** Символическая ссылка на текущий каталог процесса   
**environ** Переменные среды процесса (разделенные нулями)   
**ехе** Символическая ссылка на файл, который должен выполняться   
**fd** Подкаталог, содержащий ссылки на дескрипторы каждого открытого файла   
**fdinfo** Подкаталог, содержащий дополнительную информацию о дескрипторах кажого открытого файла   
**maps** Информация отображения памяти (сегменты совместного использования, библиотеки и т.п.)   
**ns** Подкаталог содержащий ссылку на пространство имен кажого открытого файла   
**root** Символическая ссылка на корневой каталог процесса (определенный командой chroot)   
**stat** Информация об общем состоянии процесса (для ее получения лучше всего использовать команду рs)   
**statm** Информация об использовании памяти   

## КОМАНДЫ STRCE и TRUss: ОТСЛЕЖИВАНИЕ СИГНАЛОВ И СИСТЕМНЫХ ВЫЗОВОВ
Непосредственно следить за процессами с помощью команд **strace** (в системе Linux она предоставляется в виде допол нительного пакета) или truss (в системе Free BSD). Эти команды отображают каждый системный вызов, выполняемый процессом, и каждый получаемый им сигнал.   
```
redhat $ sudo strace -р 5810
```
Команда strace снабжена флагами , которые описаны на соответствующей mаnстранице. Например, **флаг -f** используется дя разветвенных процессов, и его полезно применять дя отслеживания демонов (например, httpd), которые порожают множество дочерних процессов. Опция **-е trace=file** позволяет отображать только файловые операции , что особенно удобно для определения местоположения " неуловимых" файов конфигурации.   

## ПРОЦЕССЫ, ВЫШЕДШИЕ ИЗ-ПОД КОНТРОЛЯ
Вы можете определить процессы , которые испол ьзуют чрезмерное процессорное время, просматривая резульаты работы команд **ps** или **top**. Также проверье ***средние значения загрузки системы***, о которых сообщает команда **uptime**.    

В системе Linux общее использование центраьного процессора можно выяснить с помощью команд top или ps, которые позволяют определиь, звисят ли ***средние значения нагрузки*** от загрузки процессора или системы ввода-вывода. Если загрузка процессора составляет около 100% , это, вероятно, явяется узким местом.   

Процессы, которые избыточно используют физическую память системы, могут вызвать серьезн ые проблемы с производительностью. Вы можете проверить размер памяти, испольуемой процессами, выполнив команду top. Столбец **VIRT** показывает общий объем виртуаьной памяти, выделяемый кажым процессом, а столбец **RES** показывает часть этой памяти, отображаемую в настоящее время на определенные страницы памяти ("резидентный набор").   

Более прямой показатель потребления памяти, используемой процессом, уазан в столбце DATA, который по умолчанию не отображается. Чтобы добавить этот столбец в таблицу вывода команды top, нажмите **клавишу f** сразу поле запуск команды top и выберите пункт **DATA** из списка, нажав кавишу пробела. Значение DATA указывает объем памяти в сегментах данн ых и стека кажого процесса, поэтому он относительно специфичен дя отдельных процессов (без учета разделов общей памяти). Следите за ротом этого показтеля с течением времени, а также его аболютной величиной.   

Процессы, вышедшие из-под контроля, моrт заполнить всю файловую систему, что вызовет многочисленные проблемы.   

Первое, что нужно сделать в этой ситуации, - определить, какая файловая система зполнена и какой файл ее заполняет.   
Команда **df -h** показывает использование диска файловой системы в единицах, читаемых человеком.   
НаЙдите файловую систему, заполненную на 100% или более.   
Используйте команду du - h в идентифицированной файловой системе, чтобы определить, какой из катлогов использует наибольшее протранство.   
Повторяйте выпонять команду du до тех пор, пока не буду обнаружены большие файлы.   
Команды df и du описывают использование диска по-разному.    
Команда df сообщает о дисковой памяти, используемой смонтированной файловой системой, в соответствии с показателям и , записанными в метаданных файловой системы.    
Команда du суммирует размеры всех файлов в данном каталоге. 
Если файл отсоединен (удален) от файловой системы, но по-прежнему ссылается на какой-то запущенный процесс, команда df сообщает о занимаемом пространстве, а команда du - нет.   
Это несоответствие сохраняется до тех пор, пока дескриптор открытого файла не будет закрыт или файл не будет усечен.    

Если вы не можете определить, какой процесс использует файл , попробуйте запустить команды **fuser** и **lsof** (они подробно описаны в разделе 5.2), чтобы получить дополнительную информацию.

## ПЕРИОДИЧЕСКИЕ ПРОЦЕССЫ
### Демон cron: команды расписания
> По причинам , которые остаются неясными, демон cron в системе Red Hat был переименован в **crond**. Однако это все тот же самый cron, который все мы знаем и любим.  

Демон cron считывает файлы конфигурации, содержащие списки команд и время, в которое они должны быть вызваны. Командные строки выполняются оболочкой **sh**, поэтому почти все, что вы можете сделать вруч ную из оболочки, также можно вы полнить с помощью демона cron.   
Файл конфиграции cron называется **crontaЬ** (сокращение слов "cron tаЫе"). Файл crontab дя отдельных пользователей хранится в катаоге ***/var/ spool/ cron***   

Существует ***не более одного файла crontaЬ мя каждого пользователя*** . Файлы crontab представляют собой текстовые файлы с именами пользователей , которы м они принадлежат. Демон cron использует эти имена файлов (и их влаельца), чтобы выяснить, какой идентификатор UID применять при запуске команд, содержащихся в кажом файле. Команда crontab передает файлы crontaЬ
в этот катаог и выгружает их отуда.   

Команда **crontaЬ** помогает подерживать эффективность демона cron, уведомляя cron при изменении файлов crontaЬ. Следовательно, нельзя редактировать файлы cronta напрямую, потому что этот подход может привести к тому, что демон cron не заметит ваши изменения. 
> Если вы столкнулись с ситуацией, когда демон cron, похоже, не признает модифицированный файл cronta, сигнал **HUP**, отправленный в процесс cron, в большинстве систем заставит его перезагрузиться.

Демон cron обычно работает молча, но большинство версий могут вести файл журнаа (обычно ***/var/log/cron***), в котором перечислены команды, которые были выполнены, и моменты времени, когда они запускаись.    

#### Формат файлов crontаb
Комментарии вводятся
после знака фунта ( # ) в первом столбце строки. Каждая строка без комментария содержит шесть полей и представляет одну команду:
```
минута час день месяц день недели команда
```   
Одна минута - минимальный шаг, доступный дя работы демона cron.
> никогда н е используйте звездочки во всех полях, если не хотите, чтобы команда запускаась кажую минуту

Диапазоны времени в файе cronta могут вкючать значение шага. Например, ряд О , 3 , 6 , 9 , 1 2 , 1 5 , 1 8 можно зписать более кратко как 0 - 1 8 / 3 .   
Существует потен циал ьная двус мысленность между полями день недели и день месяца. Кажый день - это и день недели и день месяца. Если указаны значения как день недели, так и день, то день должен удоветворять тол ько одному из двух условий, которые необходимо выбрать.
Например, спецификация времени
```
0 , 3 0 * 13 * 5
```   
означает " кажые полчаса в пятницу и кажые полчаса 1 3-ro числа" , а не " кажые полчаса в пятницу 1 3-ro".   

Команда представяет собой командную строку оболочки sh, которая должна быть выполнена. Это может быть л юбая допустимая команда оболочки и ее не нужно брать в кавычки. Предполагается, что команда продолжается до конца строки и может содержать пробелы или знаки табуляции.   
Знаки процента ( % } указывают символы новой строки в поле кома нда. В фактическую команду включается только текст, стоящий до первого знака % . Остаьные строки передаются команде в качестве стандартного ввода. Используйте обратную косую черту (\} в качестве управляющего символа в командах с значащим знаком процента, например dаtе + \ % s .   
В качестве аьтернативы настройте команду cron дя непосредственного выполнения вашего сценария прямо из командной оболочки (например, ***bash -с ../Ьin/myscript . sh***).   





















