> Эви Немет, Iр Снайер, 'ент ХеАн, Бен Уэйли, Дэн Маки
> Unix и Linu: руоводство системного адинистратра
> 5-е издание

## КОМПОНЕНТЫ ПРОЦЕССА
**Процесс** состоит из аресного пространства и набора структур дан ных внутри ядра.  
В структурах данных ядра хран ится всевозможная и нформация о кажом процессе.  
**Поток** - это контекст выполнения процесса. Кажый процесс имеет как минимум оди н поток, но некоторые процессы могут иметь несколько потоков. Кажый поток,
действуя в адресном пространстве внешнего процесса, и меет свой собственный стек и регистры центраьного процессора  
### Идентификатор процесса PID
Ядро назначает каждому процессу уникаьный идентификатор. Большинство команд и с истемных вызовов, работающих с процессами, требует указания конкретного иден ­
тификатора, чтобы был ясен контекст операции. Идентификаторы ***PID присваиваются по порядку по мере созания процессов***.   
> В настоящее время система Linux испольует концепцию протранства имен процесса, которая еще больше ограничивает способность процессов видеть
друг дуга и влиять друг на друга. Контейнерные реализации используют эту функцию дя разделения процессов. Оди н из побоч н ых эффектов закл ючается в том, что ***процесс может иметь разные PID в зависимости от пространства имен наблюдателя***.
### Идентификатор родительского процесса PPID
Ни в UNIX, ни в Linux нет систем ного вызов, который б ы инициирова новый процесс дя выполнения конкретной программы. Дя того чтобы породить новый процесс, существующий процесс должен конировать сам себя. Клон может заменить выполняемую программу другой. В операции конирова н ия исходный процесс называют родительским, а его клон - дочерним. Помимо собственного идентификатора, каждый дочерний процесс имеет атрибу PPID ( Prent Process ID), который совпадает с идентификатором породившего его родителького процесса.   
По крайней мере первоначально. Если родительский процесс по какой-то причине завершается раньше потомка, демон init ии sytem (процесс с номером 1 ) подставляет себя на место предка.   
### Идентификатор пользователя UID и текущий идентификатор пользователя EUID
**UID** ( Useг ID) - это идентификатор пользователя , создавшего данн ы й процесс , точнее, копия значения U I D родительского процесса. Менять атрибуты процесса могут
только его созатель (владелец) и суперпользователь.    
**EUID** ( Eﬀective User I D) - это текущи й пользовательский идентификатор процесса, предназначенный дя того, чтобы определить, к каки м ресурсам и файлам у процесса есть право доступа в данный момент. У большинства процессов значения U I D и EU I D одинаковы. Искючение составляют программ ы, у которых установлен бит смены идентификатора пользователя ( ***setuid*** ).  
### Идентификатор группы (GID) и текущий идентификатор группы (EGID)
В значительной степени атрибут G I D процесса является рудиментарным.   
При анализе прав дотупа проверяется текущий идентификатор и дополнительный список групп , но не значение G I D.   
Единственная ситуация, в которой атрибут G I D имеет реал ьное значен ие, - создание процессом новых файлов. В зависимости от установленных прав доступа в данной файловой системе новые файлы могут принимать атрибут G 1 D созающего их процесса.   

## Жизненный цикл ПРОЦЕССА
При загрузке с исте м ы ядро самостоятельно запус кает нескол ько процессов. Наиболее важный из них - демон init или sys te с номером процесса, всегда равным 1 .  
Если родителький процесс завершается раньше срока, то ядро распознает, что вызова wait не поледует, и переназначает все "оиротевшие" процессы демону init (ил и systed). Он берет их под свой контроль, оуществяя дя каждого из н их вызов wаit.   
### Сигналы
Сигнал ы - это запросы н а прерыва н и е , реал изуе м ые н а уровне процессов.  
Когда поступает сигнал , возможен оди н из двух вариантов развития событий. Если процесс назначил сигнау подпрограмму обработки, то после вызова ей предотавляется
информация о контексте, в котором был сгенерирован сигнал. В противном случае ядро выполняет от имени процесса действия, заданные по умолчанию.    
Процедура вызова обработч ика называется переватом сигнала. Когда выполнение обработчи ка завершается , процесс возобновяется с той точки, где был получен сигна.   
### Команда kill: отправка сигналов
Команду **kill** чаще всего используют дя уничтожения процессов. Эта команда может послать процессу любой сигна, но по умолчанию это сигна **TERM**.   
Команду kill могут выполнять как рядовые пол ьзователи (для своих собствен ных процессов) , так и суперпользователь (для любого процесса). Она имеет следующий синтаксис: 
```
kill [ - сигнал ] pid
```  
где сигнал - это номер или символическое имя посылаемого сигнала (см. табл. 4. 1 ) ,   
а pid - идентификационный номер целевого процесса.   
Команда kill без номера сигнала не гарантирует, что процесс будет уничтожен, поскольку сигна TERM можно перехватывать, блокировать и игнорировать.   
Команда
```
$ kill - 9 pid
```  
"гарантированно" уничтожает процесс, так как сигна с номером 9 (KILL) не перехватывается. Используйте команду kill - 9 только в слуае, если " веживый" запро на завершение прграммы не был выполнен. М ы написаи слово " гарантированно" в кавычках, так как иногда прцессы переходт в такое сотояние, в коорм их нельзя завершить даже таким способом (обычно это связно с блокирвкой ввода-вывода, например при отановке жестког диска). Единственный выход в такой ситации - перезгузка.    
Команда **killall** уничтожает процессы , заданные именем. Например, следующая команда уничтожает все процессы веб-сервера Apache.
```
$ sudo killall httd
```   
Команда **pkill** осуществляет поиск процессов, заданных именами (или другим и атрибутами, например E U I D) , и посылает найденным процессам сигнал . Например,
следующая команда посылает сигнал T E RM всем процессам , выполняемым от имени пользователя ben.
```
$ sudo pkill -u Ьn
```   
### Состояния п роцессов и потоков
Процесс может быть приостановлен сигналом STOP и взвращен в активную нагрузку с сигнаом CONT. Сотояние приотновления или выпонения применяется к процессу в целом и наследуется всеми потками процесса.   

## КОМАНДА PS: ТЕКУЩИЙ КОНТРОЛЬ ПРОЦЕССОВ
Процессы-зомби в листинге команды обозначаются как <exiting> или <defunct> .   
Получить список всех процессов, выполняющихся в системах, можно с помощью команды 
```
ps aux
```
Ключ **а** означает, что мы хотим увидеть все процессы, ключ **х** - что мы хотим увидеть даже процессы, отсоединенные от управляющего терминала, а ключ **u** обеспечивает фил ьтрование по имени или идентификатору пользователя, который запустил программу.   

Еще одна полезная аббревиатура, **lax**, предоставляет дополнительную техническую информацию. Кючи а и х описаны выше (отображают все процессы), а кюч 1 означает выбор "динного" формата вывода данных. Команда 
```
ps lax
```   
***выполняется быстрее***, чем команда ps aux, так как не сопоставляет идентификаторы процессов с именами пользователей. Это может оказаться весьма важны м фактором , ***если система уже перегружена*** каким-то процессом.
> В командах с динными списками аргументов вывод командной строки может быть отк ючен. Чтобы отобразить на выходе больше столбцов, добавьте флаг w. Чтобы снять ограничения с ш ирины столбца, добавье флаг w дважды;   
Часто необходимо идентифицировать P I D п роцесса. Вы можете найти PI D, применив команду grep к резульатам работы команды ps:
```
$ ps au 1 grep sshd
root 6 8 1 1 О . О О . О 7 8 0 5 6 1 3 4 0 ? S s 1 6 : 0 4 0 : 0 0 / u s r / sb in / s shd
bwh a l e y 1 3 9 6 1 О . О О . О 1 1 0 4 0 8 8 6 8 pt s / 1 S + 2 0 : 3 7 0 : 0 0 grep / u s r / sb in / s shd
```   
Резульаты работы команды ps включают в себя команду grep, так как процесс grep был активен во время выполнения ps.   
Вы можете удалить эту строку из вывода с помощью команды grep -v:
```
$ ps au 1 grep -v grep 1 grep sshd
root 6 8 1 1 О . О О . О 7 8 0 5 6 1 3 4 0 ? S s 1 6 : 0 4 0 : 0 0 / u s r / sb in / s shd
```   
Можно таке определить P I D процесса с помощью команды **pidof**:
```
$ pidof /usr/sbin/sshd
6 8 1 1
```   
Кроме того, можно примен ить утилиту **pgrep**:
```
$ pgrep sshd
6 8 1 1
```   































